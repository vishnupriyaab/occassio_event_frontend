import { Observable } from 'rxjs';
import type { Socket } from 'socket.io-client';
import type { ReservedOrUserListener, ReservedOrUserEventNames, DefaultEventsMap } from '@socket.io/component-emitter';
export type IoSocket = Socket;
export type DisconnectDescription = Error | {
    description: string;
    context?: unknown;
};
interface SocketReservedEvents {
    connect: () => void;
    connect_error: (err: Error) => void;
    disconnect: (reason: Socket.DisconnectReason, description?: DisconnectDescription) => void;
}
type EventNames = ReservedOrUserEventNames<SocketReservedEvents, DefaultEventsMap>;
type EventListener<Ev extends EventNames> = ReservedOrUserListener<SocketReservedEvents, DefaultEventsMap, Ev>;
type EventParameters<Ev extends EventNames> = Parameters<EventListener<Ev>>;
type EventPayload<Ev extends EventNames> = EventParameters<Ev> extends [] ? undefined : EventParameters<Ev>[0];
type IgnoredWrapperEvents = 'receiveBuffer' | 'sendBuffer';
type WrappedSocketIface<Wrapper> = {
    [K in Exclude<keyof IoSocket, IgnoredWrapperEvents>]: IoSocket[K] extends (...args: any[]) => IoSocket ? (...args: Parameters<IoSocket[K]>) => Wrapper : IoSocket[K] extends IoSocket ? Wrapper : IoSocket[K];
};
import { SocketIoConfig } from './config/socket-io.config';
export declare class WrappedSocket implements WrappedSocketIface<WrappedSocket> {
    private config;
    private readonly subscribersCounter;
    private readonly eventObservables$;
    private readonly namespaces;
    readonly ioSocket: IoSocket;
    private readonly emptyConfig;
    constructor(config: SocketIoConfig);
    get auth(): Socket['auth'];
    set auth(value: Socket['auth']);
    /** readonly access to io manager */
    get io(): Socket['io'];
    /** alias to connect */
    get open(): WrappedSocket['connect'];
    /** alias to disconnect */
    get close(): WrappedSocket['disconnect'];
    /**
     * Gets a WrappedSocket for the given namespace.
     *
     * @note if an existing socket exists for the given namespace, it will be reused.
     *
     * @param namespace the namespace to create a new socket based on the current config.
     *        If empty or `/`, then the current instance is returned.
     * @returns a socket that is bound to the given namespace. If namespace is empty or `/`,
     *          then `this` is returned, otherwise another instance is returned, creating
     *          it if it's the first use of such namespace.
     */
    of(namespace: string): WrappedSocket;
    on<Ev extends EventNames>(eventName: Ev, callback: EventListener<Ev>): this;
    once<Ev extends EventNames>(eventName: Ev, callback: EventListener<Ev>): this;
    connect(): this;
    disconnect(): this;
    emit(_eventName: string, ..._args: any[]): this;
    send(..._args: any[]): this;
    emitWithAck<T>(_eventName: string, ..._args: any[]): Promise<T>;
    removeListener<Ev extends EventNames>(_eventName?: Ev, _callback?: EventListener<Ev>): this;
    removeAllListeners<Ev extends EventNames>(_eventName?: Ev): this;
    fromEvent<T extends EventPayload<Ev>, Ev extends EventNames>(eventName: Ev): Observable<T>;
    fromOneTimeEvent<T extends EventPayload<Ev>, Ev extends EventNames>(eventName: Ev): Promise<T>;
    listeners<Ev extends EventNames>(eventName: Ev): EventListener<Ev>[];
    hasListeners<Ev extends EventNames>(eventName: Ev): boolean;
    listenersAny(): ((...args: any[]) => void)[];
    listenersAnyOutgoing(): ((...args: any[]) => void)[];
    off<Ev extends EventNames>(eventName?: Ev, listener?: EventListener<Ev>): this;
    offAny(callback?: (event: string, ...args: any[]) => void): this;
    offAnyOutgoing(callback?: (event: string, ...args: any[]) => void): this;
    onAny(callback: (event: string, ...args: any[]) => void): this;
    onAnyOutgoing(callback: (event: string, ...args: any[]) => void): this;
    prependAny(callback: (event: string, ...args: any[]) => void): this;
    prependAnyOutgoing(callback: (event: string | symbol, ...args: any[]) => void): this;
    timeout(value: number): this;
    get volatile(): this;
    get active(): Socket['active'];
    get connected(): Socket['connected'];
    get disconnected(): Socket['disconnected'];
    get recovered(): Socket['recovered'];
    get id(): Socket['id'];
    compress(value: boolean): this;
}
export {};
